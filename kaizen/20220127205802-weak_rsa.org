:PROPERTIES:
:ID:       333f61e9-adca-4d2f-bc55-1913627d9481
:END:
#+title: Weak RSA
#+filetags: :ctf:cryptography:hackthebox:writeup:

* Description
#+begin_quote
Can you decrypt the message and get the flag?
#+end_quote

** Extras
Two files are provided for download, ~flag.enc~ and ~key.pub~.

* Recon
Results of ~file~ on ~flag.enc~ shows "data". On ~key.pub~ it shows "ASCII text".

~flag.enc~ contains:
#+begin_example
_vc[~kZ1Ĩ4I9Vֿ^G(+3Lu"$F0VP־j@|j{¾,YEXx,cN&Hl2Ӎ[o
#+end_example

~key.pub~ contains:
#+begin_example
-----BEGIN PUBLIC KEY-----
MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip
4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy
23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3
RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD
qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ
4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr
lb/N
-----END PUBLIC KEY-----
#+end_example

Since this challenge is about [[id:8643d3a6-4633-4947-bef9-42b62ed9c5d4][RSA]], it seems like we need to look into the inner-workings of the algorithm.

Using ~openssl rsa~, we can get the modulus and exponent:
#+begin_src sh
openssl rsa -pubin -text -noout -in key.pub
#+end_src
we get output of:
#+begin_example
RSA Public-Key: (1026 bit)
Modulus:
    03:30:3b:79:0f:b1:49:da:34:06:d4:95:ab:9b:9f:
    b8:a9:e2:93:44:5e:3b:d4:3b:18:ef:2f:05:21:b7:
    26:eb:e8:d8:38:ba:77:4b:b5:24:0f:08:f7:fb:ca:
    0a:14:2a:1d:4a:61:ea:97:32:94:e6:84:a8:d1:a2:
    cd:f1:8a:84:f2:db:70:99:b8:e9:77:58:8b:0b:89:
    12:92:55:8c:aa:05:cf:5d:f2:bc:63:34:c5:ee:50:
    83:a2:34:ed:fc:79:a9:5c:47:8a:78:e3:37:c7:23:
    ae:88:34:fb:8a:99:31:b7:45:03:ff:ea:9e:61:bf:
    53:d8:71:69:84:ac:47:83:7b
Exponent:
    61:17:c6:04:48:b1:39:45:1a:b5:b6:0b:62:57:a1:
    2b:da:90:c0:96:0f:ad:1e:00:7d:16:d8:fa:43:aa:
    5a:aa:38:50:fc:24:0e:54:14:ad:2b:a1:09:0e:8e:
    12:d6:49:5b:bc:73:a0:cb:a5:62:50:42:55:c7:3e:
    a3:fb:d3:6a:88:83:f8:31:da:8d:1b:9b:81:33:ac:
    21:09:e2:06:28:e8:0c:7e:53:ba:ba:4c:e5:a1:42:
    98:81:1e:70:b4:a2:31:3c:91:4a:2a:32:17:c0:2e:
    95:1a:ae:e4:c9:eb:39:a3:f0:80:35:7b:53:3a:6c:
    ca:95:17:cb:2b:95:bf:cd
#+end_example

Using simple regex and string replacement, we get:
#+begin_example
Modulus:
03303b790fb149da3406d495ab9b9fb8a9e293445e3bd43b18ef2f0521b726ebe8d838ba774bb5240f08f7fbca0a142a1d4a61ea973294e684a8d1a2cdf18a84f2db7099b8e977588b0b891292558caa05cf5df2bc6334c5ee5083a234edfc79a95c478a78e337c723ae8834fb8a9931b74503ffea9e61bf53d8716984ac47837b
Exponent:
6117c60448b139451ab5b60b6257a12bda90c0960fad1e007d16d8fa43aa5aaa3850fc240e5414ad2ba1090e8e12d6495bbc73a0cba562504255c73ea3fbd36a8883f831da8d1b9b8133ac2109e20628e80c7e53baba4ce5a14298811e70b4a2313c914a2a3217c02e951aaee4c9eb39a3f080357b533a6cca9517cb2b95bfcd
#+end_example

Converting both of them to decimal values yields:
#+begin_example
Modulus:

n = 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923

Exponent:

e = 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605
#+end_example

Conversion was done using ruby:
#+begin_src ruby
ruby<<EOF
p "value".to_i(16).to_s(10)
EOF
#+end_src

Now, we need to generate the private key. To do so, we need to do integer factorization on the modulus. This didn't work using an online factorization tool, as I had to wait for 5+ minutes. Luckily, we can look into an online database of already factored numbers ([[http://factordb.com][factordb]]). The factors are:
#+begin_example
p = 20423438101489158688419303567277343858734758547418158024698288475832952556286241362315755217906372987360487170945062468605428809604025093949866146482515539

q = 28064707897434668850640509471577294090270496538072109622258544167653888581330848582140666982973481448008792075646342219560082338772652988896389532152684857
#+end_example

* Foothold
We now can generate the private key, which we use to decrypt the encrypted file.

First, we need to compute ϕ(n). We know that ϕ(n) = (p-1) * (q-1), plugging in the above values, we get:
#+begin_example
ϕ(n) = 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676249983379244330315836562552513442311464915424205045449525362729420822096204950393746030170667472908585990772529539514978818747699190354877085506007437292528
#+end_example

We compute the private exponent:
#+begin_example
d = 44217944188473654528518593968293401521897205851340809945591908757815783834933
#+end_example

We are going to use ~openssl~ to generate the private key, we will also need to compute d mod (p-1) and d mod (q-1) and q^-1 mod p.
#+begin_example
d mod (p-1) = 44217944188473654528518593968293401521897205851340809945591908757815783834933

d mod (q-1) = 44217944188473654528518593968293401521897205851340809945591908757815783834933

q^-1 mod p =  8781217382420125056977279621675132530968943825983942088213575138391548383855591457031861314522182482985697327312492611417101340787613910676384093391819422
#+end_example

We create asn1 file:
#+begin_example
asn1=SEQUENCE:rsa_key

[rsa_key]
version=INTEGER: 0
modulus=INTEGER: 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923
pubExp=INTEGER: 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605
privExp=INTEGER: 44217944188473654528518593968293401521897205851340809945591908757815783834933
p=INTEGER: 20423438101489158688419303567277343858734758547418158024698288475832952556286241362315755217906372987360487170945062468605428809604025093949866146482515539
q=INTEGER: 28064707897434668850640509471577294090270496538072109622258544167653888581330848582140666982973481448008792075646342219560082338772652988896389532152684857
e1=INTEGER: 44217944188473654528518593968293401521897205851340809945591908757815783834933
e2=INTEGER: 44217944188473654528518593968293401521897205851340809945591908757815783834933
coeff=INTEGER: 8781217382420125056977279621675132530968943825983942088213575138391548383855591457031861314522182482985697327312492611417101340787613910676384093391819422
#+end_example

Next, we generate the private key by using the following python snippet:
#+begin_src python
from Crypto.PublicKey import RSA
n = 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923
e = 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605
d = 44217944188473654528518593968293401521897205851340809945591908757815783834933
p = 20423438101489158688419303567277343858734758547418158024698288475832952556286241362315755217906372987360487170945062468605428809604025093949866146482515539
q = 28064707897434668850640509471577294090270496538072109622258544167653888581330848582140666982973481448008792075646342219560082338772652988896389532152684857
private_key = RSA.construct((n, e, d, p, q))
private_key = private_key.exportKey()
print(private_key)
#+end_src

Lastly, we decrypt ~flag.enc~ using (after saving the key to a file ~private_key.pem~):
#+begin_src shell
openssl rsautl -decrypt -in flag.enc -out flag.txt -inkey private_key.pem
#+end_src

* Flag
#+begin_example
HTB{s1mpl3_Wi3n3rs_4tt4ck}
#+end_example
* Notes
This challenge could have been solved using the tool ~RsaCTFTool~ by providing the public key and attacking it using the database attack.
#+begin_src shell
python3 RsaCtfTool.py --publickey key.pub --dumpkey --private
#+end_src

* Resources
- Stackexchange questions regarding public/private key generation ([[https://stackoverflow.com/questions/50053884/use-rsa-public-key-to-generate-private-key-in-openssl][1]],[[https://stackoverflow.com/questions/51218492/how-to-convert-certificate-to-decimal-modulus-and-exponent][2]],[[https://stackoverflow.com/questions/19850283/how-to-generate-rsa-keys-using-specific-input-numbers-in-openssl][3]],[[https://stackoverflow.com/questions/33337904/rsa-generate-private-key-from-data-with-python][4]])
