:PROPERTIES:
:ID:       58e351f2-7c13-4848-9709-feb27596639a
:ROAM_ALIASES: XSRF CSRF
:END:
#+title: Cross Site Request Forgery
#+filetags: :owasp10:webexp:Cybersecurity:

* Overview
Cross Site Request Forgery (CSRF/XSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they don't intend to perform. It allows an attacker to partly circumbent the same origin policy, which is designed to prevent different websites from interfering with each other. The attack is also known as *one-click attack* or *session riding*.

It occurs when a user visits a page on a site, that performs an action on different site, /on which he is currently authenticated/.

CSRF works because it's the victim making the request, not the site he clicked, the vulnerable site sees that a normal request was made by the user to change his email.

If the victim is a normal user, a successful CSRF attack can force the user to perform state changing requests such as:
- Transferring funds.
- Changning email address.
- etc...
However, if the victim is an administrative account, CSRF can compromise the entire web application.

* Methodology
For a CSRF attack to be possible, three key conditions must be in place:
- A relevant action - The attacker needs a reason to target a certain user/website. The action might be privileged or normal.
- Cookie-based session handling - Performing the action invloves issuing one or more HTTP requests, and the application relies *solely* on session cookies to identify the user who has made the request. There should be no other mechanisms in place for tracking sessions or validating user requests.
    /Although CSRF is normally described in relation to cookie-based session handling, it also arises in other context where the application automatically adds some user credintials to requests, such as HTTP Basic Authentication and certificate-based authentication/.
- No unpredictable request parameters - The requests that perfrom the action don't contain any parameters whose values the attacker cannot determine or guess.
    An example of such parameters is the user's old password. Some sites will ask for the previous password to confirm the new password.

** Simple Example
For instance, let's say that a vulnerable website, ~vuln-website.com~, uses an [[id:2a8da6c9-ff7d-45a2-b0fd-9fe91fefd738][HTTP]] POST method to change emails of its users. The website also uses only cookies to validate sessions.
#+begin_example
POST /email/change HTTP/1.1
Host: vuln-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=pwned@evil.com
#+end_example

This meets the conditions required for CSRF:
- By changing the email, the attacker can do a password reset.
- The website uses session cookies to identify which user issued the request. No other metrics are in place to track user sessions.
- The attacker can easily determine the values of the request parameters that are needed to perfrom the action.

The attacker can construct a web page containing malicious [[id:c11dfdff-dac6-40ba-b8a0-f37e30abe8fc][HTML]] code:
#+begin_src html
<html>
  <body>
    <form action="https://vuln-website.com/email/change" method="POST" id ="csrf_form">
      <input type="hidden" name="email" value="pwned@evil.com" />
    </form>
    <script>
      document.getElementById('csrf_form').submit()
    </script>
  </body>
</html>
#+end_src

When a user clicks on a the link to a website created by a hacker ([[id:a8d703d0-1c91-4974-9c5c-9e09b82523e9][phishing]]), the attacker's page will trigger an HTTP request to the vulnerable website. If the user is logged in, their browser will automatically include their session cookie in the request. The website will treat the request as if it has been made by the victim user, and it will change his email address.

* Construction
Other than manually creating CSRF payloads and injecting them inside HTML, one can use some tools to automate the PoC (proof-of-concept) generation:
- Burp Suite has an option in the engagement tools to generate CSRF PoC.
- XSRFProbe can be used to detect and generate CSRF attacks.

* Delivery
Typically, the attacker will place the malicious HTML onto a website that they control, and then induce victims to visit that website. The attack might also be placed into a comment, the attacker will just have to wait for people to visit the comment's webpage.

Some websites use GET methods to make actions such as changing an email. The attacker can send a URL to the victim, or simply embed an image with the payload as its src tag.
#+begin_src html
<img src="https://vuln-website.com/email/change?email=pwned@evil.com">
#+end_src

* Mitigation
** CSRF Token
A CSRF token is a unique, secret, unpredictable value that is generated by the server-side application and transmitted to the client in such a way that it is included in a subsequent HTTP request made by the client. The server checks and validates the token, and rejects if its missing or invalid.

CSRF token make it hard for attackers to predict and construct valid HTTP requests suitable for feeding to a victim user.

There are two general apporaches to CSRF tokens:
- Stateful
- Stateless

  The difference between the two approaches is whether or not the server needs to save the token locally. With *stateful* tokens, the server will check the existence and validity of the token to that which is saved on the server. On the other hand, *stateless* tokens are generated on the server using a combination of session ID of the user and a timestamp (and other stuff mayber) and then encrypted, its also not stored locally. When any request is made from the user side, the server application will decrypt the token using the secret key. If the session ID matches the current session ID, and the timestamp is within the time of expiry, the request is accepted.

*** Generation
CSRF tokens, also known as synchronizer token pattern (STP), should contain significant entropy and be unpredictable. An acceptable way to do so, is to use a [[id:161ddc43-35eb-40a0-ac4d-315afc63121d][PRNG]] seeded with the timestamp when it was created alongside a static secret.

To prevent against attempted pattern analysis, we can increase the unpredictability of the token in several ways:
- User-specific entropy (mouse movement for example).
- Hashing the whole structure.

Using Shannon Entropy method, we can check if a token is strong or not, a token above ~2.4~ entropy is considered strong and un-forable. An entropy lower than that of ~2.4~ isn't considered random enough and can easily be forged via guessing/bruteforcing.

*** Transmittion
CSRF tokens should be transmitted through:
- Hidden fields used in forms.
- Headers used in [[id:a8674408-c841-4212-9b34-e474b1387b6c][AJAX]] calls.

CSRF tokens shouldn't be transmitted within cookies, this defeats the purpose of this method. The attacker will not have to worry about sending the correct values, the browser will send the token as part of the cookie.

Since these tokens should be treated as secrets and handled in a secure manner throught their lifecycle, we need to be careful of how we transmit them to the user.

An apporach that can be effective is to transmit them to the client within a hidden field of an HTML form that is submitted using the POST method. The token will be included as a request parameter when the form is submitted.
#+begin_src html
<input type="hidden" name="csrf-token" value="randomToKeN12345" />
#+end_src
The field containing the CSRF token should be placed as early as possible within the HTML document, ideally before any non-hidden inputs fields and before any location where user-controllable data is embedded within the HTML. This mitigates agains techniques in which an attacker can use crafted data to manipulate the HTML document and caputre parts of its content.

Another approach is to transmit CSRF tokens using a custom request header. If an attacker is successful in catching a user's token, he wouldn't be able to use it since the browser blocks cross-domain requests with custom headers ([[id:a0dac5f6-cdae-41ff-b2ea-abe9ebd6f860][Same Origin Policy]]).

*** Validation
The CSRF token should be stored server-side upon generation. It should be saved within the user's session data. When subsequent requests are made, the server-side application should verify that the request includes a token which matches the value that was stored in the user's session.

The validation must be performed regardless of the HTTP method or content type of the request. If any request is made without the token, or with an invalid token, it gets rejected.

STP relies only on HTML, but introduces some complexity on the server side, due to the burden associated with checking validity of the token on each request. This can be relaxed by using a per session CSRF token instead of per request CSRF token.

** Cookie-to-header Token
Websites that use [[id:50e7f683-acd1-4ceb-994a-d371c7c28be3][Javascript]] for the majority of their operations may use the following anti-CSRF technique:
1. When creating user session (upon first interaction), the website sets up a cookie with a CSRF token included.
#+begin_example
Set-Cookie: __Host-csrf_token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; Expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=/; SameSite=Lax; Secure
#+end_example
2. The client side code reads its value and copies it into a custom HTTP header sent with each subsequent request:
#+begin_example
X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql
#+end_example
3. The server validates presence and integrity of the token.

Note that the initial cookie must not have httpOnly flag set, as its intended to be read by the Javascript by design.

** SameSite Cookies
The SameSite attribute can be used to control whether and how cookies are submitted. An application can prevent the default behavior of browsers of automatically adding cookies to requests regardless of where they originated.

The SameSite attribute is added to the Set-Cookie response header when the server issues a cookie. SameSite has two values:
- Strict
  #+begin_example
  Set-Cookie: SessionId=sid_value; SameSite=Strict;
  #+end_example
  The browser will not include the cookie in any requests that originate from another site.
- Lax
  #+begin_example
  Set-Cookie: SessionId=sid_value; SameSite=Lax;
  #+end_example
  The browser includes cookies in requests originated from other sites but only under two conditions:
  + The request uses GET method (others will not include).
  + The request was resulted from user navigation and not script action.

** Double Submit
Some applications don't maintain any server-side record of tokens that have been issued. They duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie.

An example code of using double submit to prevent against login CSRF attacks:
#+begin_src php
 <?php
    if (isset($_POST["user"], $_POST["pass"]){
        // Make sure the token from the login form is the same as in the cookie
        if (isset($_POST["CSRFtoken"], $_COOKIE["CSRFtoken"])){
            if ($_POST["CSRFtoken"] == $_COOKIE["CSRFtoken"]){
                // code for checking the user and password
            }
        }
    } else {
        $token = bin2hex(openssl_random_pseudo_bytes(16));
        setcookie("CSRFtoken", $token, time() + 60 * 60 * 24);
        echo '
            <form method="post">
                <input name="user">
                <input name="pass" type="password">
                <input name="CSRFtoken" type="hidden" value="' . $token . '">
                <input type="submit">
            </form>
        '
    }
?>
#+end_src

** Referer Based Defenses
Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks. They check if the request originated from the application's own domain.

This is done by setting the HTTP Referer header and/or HTTP Origin header.

Since HTTP Origin header contains less information than HTTP Referer header, less browser delete this header when sending requests. Applications can take advantage of Origin to imnplement simplified CSRF protection that cheks its value against a known whitelist instead of using a token and cookie. Since Origin is a forbidden header (can't be altered programmatically), apps receiving it can rely on its validity.

* Vulnerabilities
- Some applications skip the validation of CSRF tokens when the request uses GET instead of POST.
- Some applications skip the validation of CSRF tokens if the token is omitted (alongside its parameter).
- Some applications don't validate that the token belongs to the same session as the user who is making the request. It accepts the token after its compared to the global pool of token previously generated. The attacker can use his own token to bypass this defense.
- Some applications do tie the CSRF token to a cookie, but not the session cookie. This can occur when the application employs two different frameworks, one for session handling, and one for CSRF protection, without any integration between the two. If the attacker can set a cookie in a victim's browser, then using his own cookie, the attacker can inject a valid CSRF cookie and leave out the session token.
- If the application allows for cookie setting functionality, then an attacker can bypass the double submit defense. The attacker can perform a CSRF attack by inventing a token, and then placing it into the victim's browser.
- To bypass referer based defenses, the attacker can craft their CSRF exploit in a way that causes the victim's browser to drop the Referer header in the resulting request. This can be done using the META tag within the HTML page.
    #+begin_src html
    <meta name="referer" content="never">
    #+end_src
- A naive way to check for Referer header is if the request domain starts with the website name. The attacker can simply use the vulnerable website domain name as a subdomian.

* Variations
** Login CSRF
Login CSRF is a type of attack where the attacker can force the user to log into the attacker's account on a website and thus reveal information about what the user is doing while logged in.

If the program doesn't check where the credentials came from, then the attacker can create an HTML page which submits a POST request using his own login information.

#+begin_src php
<?php
    if (isset($_POST["user"], $_POST["pass"])){
        // code for checking the user and password
    } else {
        echo '
            <form method="post">
                <input name="user">
                <input name="pass" type="password">
                <input type="submit">
            </form>
        ';
    }
?>
#+end_src

The attacker then creates a website with the following code:
#+begin_src html
<form id="LoginForm" action="http://vuln-website/login.php" method="post">
    <input name="user" value="evil">
    <input name="pass" type="password" value="haha">
    <input type="submit">
</form>

<script>
    document.getElementById("LoginForm").submit();
</script>
#+end_src

** Dynamic CSRF
* Resources
- TryHackMe's [[https://tryhackme.com/room/zthobscurewebvulns][room]]: "ZTH: Obscure Web Vulns"
- OWASP's [[https://owasp.org/www-community/attacks/csrf][page]] about CSRF
- PortSwigger's 3 part series about CSRF ([[https://portswigger.net/web-security/csrf][introduction]], [[https://portswigger.net/web-security/csrf/samesite-cookies][SameSite]], [[https://portswigger.net/web-security/csrf/tokens][tokens]])
- [[https://github.com/0xInfection/XSRFProbe][XSRFProbe]] wiki and documentation
- [[https://www.youtube.com/watch?v=eWEgUcHPle0][Cross-Site Request Forgery (CSRF) Explained]]
- [[https://support.detectify.com/support/solutions/articles/48001048951-login-csrf][Login CSRF]]
- Wikipedia's [[https://en.wikipedia.org/wiki/Cross-site_request_forgery][article]] about CSRF
- [[https://brandur.org/fragments/origin][Simple and stateless CSRF protection with the "Origin" header]]
- [[https://blog.sessionstack.com/how-javascript-works-csrf-attacks-7-mitigation-strategies-757dfb08e7a6][How JavaScript works: CSRF attacks + 7 mitigation stratigies]]
- [[https://www.blackhat.com/presentations/bh-usa-09/HAMIEL/BHUSA09-Hamiel-DynamicCSRF-PAPER.pdf][Dynamic CSRF]]
- Owasp's multiple articles about CSRF ([[https://owasp.org/www-community/attacks/csrf][1]], [[https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html][2]])
